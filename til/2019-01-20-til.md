# 다른사람이 짠 코드 분석 완료된 후 블로그쪽으로 커밋 예정


# 명령 프롬프트

출처: <a href="https://www.acmicpc.net/problem/1032" target="_blank">백준 알고리즘 1032번 문제</a>

## 문제

시작 -> 실행 -> cmd를 쳐보자. 검정 화면이 눈에 보인다.

여기서 dir이라고 치면 그 디렉토리에 있는 서브디렉토리와 파일이 모두 나온다.

이때 원하는 파일을 찾으려면 다음과 같이 하면 된다.

dir *.exe라고 치면 확장자가 exe인 파일이 다 나온다.

"dir 패턴"과 같이 치면 그 패턴에 맞는 파일만 검색 결과로 나온다.

예를 들어, dir a?b.exe라고 검색하면 파일명의 첫 번째 글자가 a이고,

세 번째 글자가 b이고, 확장자가 exe인 것이 모두 나온다.

이때 두 번째 문자는 아무거나 나와도 된다.

예를 들어, acb.exe, aab.exe, apb.exe가 나온다.

이 문제는 검색 결과가 먼저 주어졌을 때,

패턴으로 뭘 쳐야 그 결과가 나오는지를 출력하는 문제이다.

패턴에는 알파벳과 "." 그리고 "?"만 넣을 수 있다.

가능하면 ?을 적게 써야 한다.

그 디렉토리에는 검색 결과에 나온 파일만 있다고 가정하고, 파일 이름의 길이는 모두 같다.


## 입력

첫째 줄에 파일 이름의 개수 N이 주어진다.

둘째 줄부터 N개의 줄에는 파일 이름이 주어진다.

N은 50보다 작거나 같은 자연수이고 파일 이름의 길이는 모두 같고 길이는 최대 50이다.

파일이름은 알파벳과 "." 그리고 "?"로만 이루어져 있다.


## 출력

첫째 줄에 패턴을 출력하면 된다.



```
예제입력
    3
    config.sys
    config.inf
    configures

예제출력
    config????
```

## 내 풀이

```python
  1 import sys
  2
  3 n = int(sys.stdin.readline())
  4 file_name_list = []
  5
  6 for i in range(n):
  7     file_name_list.append(sys.stdin.readline().rstrip())
  8
  9 pattern = list(file_name_list[0])
 10
 11 for file_name in file_name_list[1:]:
 12     for i in range(len(file_name)):
 13         if pattern[i] == "?":
 14             pass
 15         elif pattern[i] != file_name[i]:
 16             pattern[i] = "?"
 17
 18 print("".join(pattern))
```

컨셉은 아주 단순하다.

입력받은 문자들 중 맨 처음 받은 문자를 기준으로 나머지 문자를 하나씩 비교했다.

문자를 하나씩 비교하며 다른 부분은 바로 "?" 기호로 바꿔주면 된다.

(9) 맨 처음 받은 문자를 한 글자씩 쪼개어 리스트로 만들어주었다.

리스트로 만든 이유는 비교를하며 바로바로 문자열을 바꾸기 용이하게 하기 위함이다.

만약 문자열 그대로 비교하게되면 특정 문자열만 "?"로 치환하는데 있어서 살짝 까다롭다.

(11) 첫 번째로 받은 문자열은 비교의 기준(pattern)으로 사용했으므로,

2번째 문자열(1번인덱스)부터 시작해 이터레이션을 돌린다.

(13) 특정 순서의 패턴이 물음표라면, 이미 치환된 것이므로 물음표 그대로 놔두고 pass한다.

(14) 특정 순서의 패턴과 문자열이 서로 다르다면, 해당 순서의 패턴을 물음표로 바꾼다.

(18) 리스트를 모두 이어붙여서 패턴 문자열을 출력한다.


## 다른사람 풀이

```python
  1 N=int(input());*x,=(input()for _ in range(N));print(''.join([i[0],'?'][i.count(i[0])<N]for i in zip(\*x)))
```

아주 재밌는 코드를 발견했다.

원본코드는 한줄로 쭉 이어져있었지만, 가독성을 위해 개행을 해보자.

```python
  1 N=int(input())
  2 *x,=(input()for _ in range(N))
  3 print(''.join([i[0],'?'][i.count(i[0])<N]for i in zip(\*x)))
```

첫번째 줄은 특이사항 없다.

두번째 줄을 보면 input을 for문을 돌며 받았는데, generator expression형태로 받았다.

## 분석

생각이 좀 필요한 문제였다.

처음엔 너무 쉽게 생각했다가,

어찌보면 나중엔 너무 어렵게 생각했던 것 같기도 하다.

<br/>

문제를 풀고 다른사람들은 어떻게 풀었나 봤더니 그래프의 연결성(?)을 이용해서 풀었더라.

증인과 그와 접촉했던 모든 사람들을 연쇄적으로 연결하고,

연결된 노드를 거짓말 파티에서 제외하는 식으로 풀었다. (내가 개념이 부족해서 설명이 빈약하다)

<br/>

어쨌든 로직 자체는 내가 푼것과 거의 같다고 보면 되지만,

개념적인 기반이 탄탄해보였고, 때문에 설명도 더 깔끔했기에 보다 전문적으로 느껴졌다.

다른 풀이가 궁금하면 여기 링크 걸어놓은 <a href="https://syogeng.wordpress.com/2017/09/18/%EB%B0%B1%EC%A4%80-1043-%EA%B1%B0%EC%A7%93%EB%A7%90/" target="_blank">"빰" 님 브로그</a> 에서 확인해보길 바란다.

<br/>

그리고 한 번 거짓말을 하게되면 마치 암세포가 퍼지듯  그 사람이 만나는 수많은 사람에게 나의 거짓말이 전파(?)된다는 뜻밖의 교훈도 얻을 수 있었는데,

블로그를 하다가 혹시 잘못된 정보를 올려 이와 비슷한 사단을 내지 않도록 충분한 공부가 필요하다는 생각이 들었다.

<br/>

전혀 상상하지 못한 곳에서 전혀 상상하지 못한 교훈을 얻게되는것 또한 코딩의 매력이 아닐까 싶다.

단순히 알고리즘을 풀어내는 것 뿐 아니라 스토리 속에서 교훈을 얻을 수 있는 좋은 문제를 만들어준 백준님께도 감사의 말씀 올린다.
